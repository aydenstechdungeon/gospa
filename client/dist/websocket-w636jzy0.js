import{X as D,Y as $}from"./runtime-zmh0xn4h.js";import"./runtime-nmjc1qqb.js";var P=new Set(["init","update","sync","error","ping","pong","action"]);function T(F){if(!F||typeof F!=="object"||Array.isArray(F))return null;let q=F;if(typeof q.type!=="string"||!P.has(q.type))return null;let z={type:q.type};if(typeof q.componentId==="string")z.componentId=q.componentId;if(typeof q.action==="string")z.action=q.action;if(q.data&&typeof q.data==="object"&&!Array.isArray(q.data))z.data=q.data;if(q.payload&&typeof q.payload==="object"&&!Array.isArray(q.payload))z.payload=q.payload;if(q.state&&typeof q.state==="object"&&!Array.isArray(q.state))z.state=q.state;if(q.diff&&typeof q.diff==="object"&&!Array.isArray(q.diff))z.diff=q.diff;if(typeof q.error==="string")z.error=q.error;if(typeof q.timestamp==="number")z.timestamp=q.timestamp;if(typeof q.sessionToken==="string")z.sessionToken=q.sessionToken;if(typeof q.clientId==="string")z.clientId=q.clientId;return z}var G="gospa_session";function h(){try{let F=G+"=",q=document.cookie.split(";");for(let z=0;z<q.length;z++){let H=q[z];while(H.charAt(0)===" ")H=H.substring(1);if(H.indexOf(F)===0){let J=decodeURIComponent(H.substring(F.length,H.length));return JSON.parse(J)}}}catch(F){console.warn("[GoSPA] Failed to load session:",F)}return null}function M(F){try{let q=new Date;q.setTime(q.getTime()+604800000);let z="expires="+q.toUTCString(),H=encodeURIComponent(JSON.stringify(F)),J=`${G}=${H};${z};path=/;SameSite=Strict`;if(window.location.protocol==="https:")J+=";Secure";document.cookie=J}catch(q){console.warn("[GoSPA] Failed to save session:",q)}}class L{ws=null;config;reconnectAttempts=0;heartbeatTimer=null;messageQueue=[];connectionState;pendingRequests=new Map;requestId=0;sessionData=null;constructor(F){this.config={reconnect:!0,reconnectInterval:1000,maxReconnectAttempts:10,heartbeatInterval:30000,onOpen:()=>{},onClose:()=>{},onError:()=>{},onMessage:()=>{},...F},this.connectionState=new $("disconnected"),this.sessionData=h()}get state(){return this.connectionState.get()}get isConnected(){return this.connectionState.get()==="connected"}connect(){return new Promise((F,q)=>{if(this.ws?.readyState===WebSocket.OPEN){F();return}this.connectionState.set("connecting");try{this.ws=new WebSocket(this.config.url)}catch(z){this.connectionState.set("disconnected"),q(z);return}this.ws.onopen=()=>{if(this.connectionState.set("connected"),this.reconnectAttempts=0,this.startHeartbeat(),this.sessionData?.token)this.send({type:"init",sessionToken:this.sessionData.token,clientId:this.sessionData.clientId});this.flushMessageQueue(),this.send({type:"sync"}),this.config.onOpen(),F()},this.ws.onclose=(z)=>{if(this.connectionState.set("disconnected"),this.stopHeartbeat(),this.config.onClose(z),this.config.reconnect&&this.reconnectAttempts<this.config.maxReconnectAttempts)this.scheduleReconnect()},this.ws.onerror=(z)=>{if(this.config.onError(z),this.connectionState.get()==="connecting")q(Error("WebSocket connection failed"))},this.ws.onmessage=(z)=>{this.handleMessage(z.data)}})}disconnect(){if(this.ws)this.connectionState.set("disconnecting"),this.stopHeartbeat(),this.ws.close(1000,"Client disconnect"),this.ws=null,this.connectionState.set("disconnected")}scheduleReconnect(){this.reconnectAttempts++;let F=this.config.reconnectInterval*Math.min(this.reconnectAttempts,5);setTimeout(()=>{if(this.connectionState.get()==="disconnected")this.connect().catch(()=>{})},F)}startHeartbeat(){this.heartbeatTimer=setInterval(()=>{this.send({type:"ping"})},this.config.heartbeatInterval)}stopHeartbeat(){if(this.heartbeatTimer)clearInterval(this.heartbeatTimer),this.heartbeatTimer=null}flushMessageQueue(){while(this.messageQueue.length>0&&this.isConnected){let F=this.messageQueue.shift();if(F)this.send(F)}}send(F){if(this.ws?.readyState===WebSocket.OPEN)this.ws.send(JSON.stringify(F));else this.messageQueue.push(F)}sendWithResponse(F){return new Promise((q,z)=>{let H=`req_${++this.requestId}`;F.data={...F.data,_requestId:H},this.pendingRequests.set(H,{resolve:q,reject:z}),this.send(F),setTimeout(()=>{if(this.pendingRequests.has(H))this.pendingRequests.delete(H),z(Error("Request timeout"))},30000)})}handleMessage(F){try{let q=JSON.parse(F),z=T(q);if(!z){console.warn("[GoSPA] Received invalid WebSocket message, ignoring");return}if(z.type==="pong")return;if(z.type==="init"&&z.sessionToken&&z.clientId)this.sessionData={token:z.sessionToken,clientId:z.clientId},M(this.sessionData);if(z.data?._responseId){let H=z.data._responseId,J=this.pendingRequests.get(H);if(J)if(this.pendingRequests.delete(H),z.type==="error")J.reject(Error(z.error||"Unknown error"));else J.resolve(z.data)}this.config.onMessage(z)}catch(q){console.error("Failed to parse WebSocket message:",q)}}requestSync(){this.send({type:"sync"})}sendAction(F,q={}){this.send({type:"action",action:F,payload:q})}requestState(F){return this.sendWithResponse({type:"init",componentId:F})}}function b(F,q={}){if(Q)Q.sendAction(F,q);else console.warn("[GoSPA] Cannot send action: WebSocket not initialized")}var Q=null;function x(){return Q}function A(F){if(Q)Q.disconnect();return Q=new L(F),Q}function N(F,q){let z=new $(F),H=q.ws||Q,J=!1,U=z.set.bind(z);return z.set=(Z)=>{if(J){U(Z);return}let B=z.get();if(U(Z),H?.isConnected)try{let X=()=>{H.send({type:"update",payload:{key:q.key,value:Z}})};if(q.debounce)setTimeout(X,q.debounce);else X()}catch(X){console.warn("[GoSPA] Optimistic update failed, rolling back.",X),J=!0,U(B),J=!1}else console.warn("[GoSPA] WS disconnected, optimistic update rolled back."),J=!0,U(B),J=!1},z}function f(F,q,z){let H=z||Q;if(!H?.isConnected)return;for(let[J,U]of Object.entries(q))H.send({type:"update",payload:{key:J,value:U.get()}})}function Y(F,q){D(()=>{for(let[z,H]of Object.entries(q)){let J=F[z];if(J)J.set(H)}})}export{N as syncedRune,f as syncBatch,b as sendAction,A as initWebSocket,x as getWebSocketClient,Y as applyStateUpdate,L as WSClient};
export{L as u,b as v,x as w,A as x,N as y,Y as z};
