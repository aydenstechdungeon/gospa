package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// RouteTypeScriptGenerator generates type-safe route helpers for TypeScript.
type RouteTypeScriptGenerator struct {
	routes     []RouteInfo
	modulePath string
}

// NewRouteTypeScriptGenerator creates a new route TypeScript generator.
func NewRouteTypeScriptGenerator(routes []RouteInfo, modulePath string) *RouteTypeScriptGenerator {
	return &RouteTypeScriptGenerator{
		routes:     routes,
		modulePath: modulePath,
	}
}

// GenerateRoutesFile generates a comprehensive routes.ts file with type-safe helpers.
func (g *RouteTypeScriptGenerator) GenerateRoutesFile(outputDir string) error {
	var sb strings.Builder

	sb.WriteString("// Code generated by GoSPA. DO NOT EDIT.\n")
	sb.WriteString("// Run: go generate ./...\n\n")

	// Generate route path types
	sb.WriteString("// ============================================\n")
	sb.WriteString("// Route Path Types\n")
	sb.WriteString("// ============================================\n\n")

	g.generateRoutePaths(&sb)

	// Generate route params types
	sb.WriteString("\n// ============================================\n")
	sb.WriteString("// Route Parameter Types\n")
	sb.WriteString("// ============================================\n\n")

	g.generateRouteParams(&sb)

	// Generate route query types
	sb.WriteString("\n// ============================================\n")
	sb.WriteString("// Route Query Types\n")
	sb.WriteString("// ============================================\n\n")

	g.generateRouteQuery(&sb)

	// Generate route builder
	sb.WriteString("\n// ============================================\n")
	sb.WriteString("// Route Builder Functions\n")
	sb.WriteString("// ============================================\n\n")

	g.generateRouteBuilder(&sb)

	// Generate route helpers
	sb.WriteString("\n// ============================================\n")
	sb.WriteString("// Route Helper Functions\n")
	sb.WriteString("// ============================================\n\n")

	g.generateRouteHelpers(&sb)

	// Generate navigation helpers
	sb.WriteString("\n// ============================================\n")
	sb.WriteString("// Navigation Helpers\n")
	sb.WriteString("// ============================================\n\n")

	g.generateNavigationHelpers(&sb)

	// Generate route registry
	sb.WriteString("\n// ============================================\n")
	sb.WriteString("// Route Registry\n")
	sb.WriteString("// ============================================\n\n")

	g.generateRouteRegistry(&sb)

	// Write to file
	outPath := filepath.Join(outputDir, "routes.ts")
	return os.WriteFile(outPath, []byte(sb.String()), 0644)
}

// generateRoutePaths generates the route path type definitions.
func (g *RouteTypeScriptGenerator) generateRoutePaths(sb *strings.Builder) {
	sb.WriteString("/**\n")
	sb.WriteString(" * All available route paths as a union type.\n")
	sb.WriteString(" * Use this for type-safe route references.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export type RoutePath = \n")

	// Sort routes for consistent output
	sort.Slice(g.routes, func(i, j int) bool {
		return g.routes[i].URLPath < g.routes[j].URLPath
	})

	for i, route := range g.routes {
		if route.IsLayout {
			continue
		}
		if i > 0 {
			sb.WriteString("  | ")
		} else {
			sb.WriteString("  | ")
		}
		sb.WriteString(fmt.Sprintf("%q\n", route.URLPath))
	}

	sb.WriteString(";\n\n")

	// Generate route map type
	sb.WriteString("/**\n")
	sb.WriteString(" * Route path map for looking up routes by name.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export interface RouteMap {\n")

	for _, route := range g.routes {
		if route.IsLayout {
			continue
		}
		// Create a route name from the path
		name := g.pathToName(route.URLPath)
		sb.WriteString(fmt.Sprintf("  %s: %q;\n", name, route.URLPath))
	}

	sb.WriteString("}\n")
}

// generateRouteParams generates route parameter type definitions.
func (g *RouteTypeScriptGenerator) generateRouteParams(sb *strings.Builder) {
	sb.WriteString("/**\n")
	sb.WriteString(" * Extract route parameters from a route path.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export type RouteParams<T extends RoutePath> = T extends any ? (\n")

	for _, route := range g.routes {
		if route.IsLayout {
			continue
		}
		if len(route.RouteParams) > 0 {
			sb.WriteString(fmt.Sprintf("  T extends %q ? { ", route.URLPath))
			for i, param := range route.RouteParams {
				if i > 0 {
					sb.WriteString("; ")
				}
				sb.WriteString(fmt.Sprintf("%s: string | number", param))
			}
			sb.WriteString(" } :\n")
		}
	}

	sb.WriteString("  never\n")
	sb.WriteString(") : never;\n\n")

	// Generate individual route param interfaces
	sb.WriteString("/**\n")
	sb.WriteString(" * Individual route parameter interfaces.\n")
	sb.WriteString(" */\n")

	for _, route := range g.routes {
		if route.IsLayout || len(route.RouteParams) == 0 {
			continue
		}
		name := g.pathToName(route.URLPath)
		sb.WriteString(fmt.Sprintf("export interface %sParams {\n", name))
		for _, param := range route.RouteParams {
			sb.WriteString(fmt.Sprintf("  %s: string | number;\n", param))
		}
		sb.WriteString("}\n\n")
	}
}

// generateRouteQuery generates route query parameter type definitions.
func (g *RouteTypeScriptGenerator) generateRouteQuery(sb *strings.Builder) {
	sb.WriteString("/**\n")
	sb.WriteString(" * Route query parameters interface.\n")
	sb.WriteString(" * Extend this interface to add type-safe query params.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export interface RouteQuery {\n")
	sb.WriteString("  // Add your query parameters here\n")
	sb.WriteString("  // Example: search?: string; page?: number;\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Build a query string from an object.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function buildQuery(params: RouteQuery): string {\n")
	sb.WriteString("  const searchParams = new URLSearchParams();\n")
	sb.WriteString("  for (const [key, value] of Object.entries(params)) {\n")
	sb.WriteString("    if (value !== undefined && value !== null && value !== '') {\n")
	sb.WriteString("      searchParams.set(key, String(value));\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")
	sb.WriteString("  const query = searchParams.toString();\n")
	sb.WriteString("  return query ? `?${query}` : '';\n")
	sb.WriteString("}\n")
}

// generateRouteBuilder generates the route builder functions.
func (g *RouteTypeScriptGenerator) generateRouteBuilder(sb *strings.Builder) {
	sb.WriteString("/**\n")
	sb.WriteString(" * Build a URL for a route with type-safe parameters.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function buildRoute<T extends RoutePath>(\n")
	sb.WriteString("  path: T,\n")
	sb.WriteString("  ...args: RouteParams<T> extends never ? [] : [params: RouteParams<T>]\n")
	sb.WriteString("): string {\n")
	sb.WriteString("  let result = path as string;\n")
	sb.WriteString("  \n")
	sb.WriteString("  if (args.length > 0) {\n")
	sb.WriteString("    const params = args[0] as Record<string, string | number>;\n")
	sb.WriteString("    for (const [key, value] of Object.entries(params)) {\n")
	sb.WriteString("      result = result.replace(`:${key}`, String(value));\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  return result;\n")
	sb.WriteString("}\n\n")

	// Generate individual route builders
	sb.WriteString("/**\n")
	sb.WriteString(" * Individual route builder functions for better IDE support.\n")
	sb.WriteString(" */\n")

	for _, route := range g.routes {
		if route.IsLayout {
			continue
		}
		funcName := g.pathToFuncName(route.URLPath)

		if len(route.RouteParams) > 0 {
			sb.WriteString(fmt.Sprintf("export function %s(params: { ", funcName))
			for i, param := range route.RouteParams {
				if i > 0 {
					sb.WriteString("; ")
				}
				sb.WriteString(fmt.Sprintf("%s: string | number", param))
			}
			sb.WriteString(fmt.Sprintf(" }): string {\n"))
			sb.WriteString(fmt.Sprintf("  return buildRoute(%q, params);\n", route.URLPath))
			sb.WriteString("}\n\n")
		} else {
			sb.WriteString(fmt.Sprintf("export function %s(): string {\n", funcName))
			sb.WriteString(fmt.Sprintf("  return %q;\n", route.URLPath))
			sb.WriteString("}\n\n")
		}
	}
}

// generateRouteHelpers generates route helper functions.
func (g *RouteTypeScriptGenerator) generateRouteHelpers(sb *strings.Builder) {
	sb.WriteString("/**\n")
	sb.WriteString(" * Check if a path matches a route pattern.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function matchRoute(pattern: string, path: string): boolean {\n")
	sb.WriteString("  const patternParts = pattern.split('/').filter(Boolean);\n")
	sb.WriteString("  const pathParts = path.split('/').filter(Boolean);\n")
	sb.WriteString("  \n")
	sb.WriteString("  if (patternParts.length !== pathParts.length) {\n")
	sb.WriteString("    return false;\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  for (let i = 0; i < patternParts.length; i++) {\n")
	sb.WriteString("    const patternPart = patternParts[i];\n")
	sb.WriteString("    const pathPart = pathParts[i];\n")
	sb.WriteString("    \n")
	sb.WriteString("    if (!patternPart.startsWith(':') && patternPart !== pathPart) {\n")
	sb.WriteString("      return false;\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  return true;\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Extract parameters from a path matching a route pattern.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function extractParams<T extends RoutePath>(\n")
	sb.WriteString("  pattern: T,\n")
	sb.WriteString("  path: string\n")
	sb.WriteString("): RouteParams<T> | null {\n")
	sb.WriteString("  const patternParts = pattern.split('/').filter(Boolean);\n")
	sb.WriteString("  const pathParts = path.split('/').filter(Boolean);\n")
	sb.WriteString("  const params: Record<string, string> = {};\n")
	sb.WriteString("  \n")
	sb.WriteString("  if (patternParts.length !== pathParts.length) {\n")
	sb.WriteString("    return null;\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  for (let i = 0; i < patternParts.length; i++) {\n")
	sb.WriteString("    const patternPart = patternParts[i];\n")
	sb.WriteString("    const pathPart = pathParts[i];\n")
	sb.WriteString("    \n")
	sb.WriteString("    if (patternPart.startsWith(':')) {\n")
	sb.WriteString("      params[patternPart.slice(1)] = pathPart;\n")
	sb.WriteString("    } else if (patternPart !== pathPart) {\n")
	sb.WriteString("      return null;\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  return params as RouteParams<T>;\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Check if a route path is active (matches current path).\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function isRouteActive(path: RoutePath, currentPath: string): boolean {\n")
	sb.WriteString("  // Exact match\n")
	sb.WriteString("  if (currentPath === path) {\n")
	sb.WriteString("    return true;\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  // Prefix match for index routes\n")
	sb.WriteString("  if (path !== '/' && currentPath.startsWith(path)) {\n")
	sb.WriteString("    const nextChar = currentPath.charAt(path.length);\n")
	sb.WriteString("    return nextChar === '/' || nextChar === '';\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  return false;\n")
	sb.WriteString("}\n")
}

// generateNavigationHelpers generates navigation helper functions.
func (g *RouteTypeScriptGenerator) generateNavigationHelpers(sb *strings.Builder) {
	sb.WriteString("/**\n")
	sb.WriteString(" * Navigation options for programmatic navigation.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export interface NavigateOptions {\n")
	sb.WriteString("  replace?: boolean;\n")
	sb.WriteString("  query?: RouteQuery;\n")
	sb.WriteString("  state?: Record<string, unknown>;\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Navigate to a route programmatically.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function navigate<T extends RoutePath>(\n")
	sb.WriteString("  path: T,\n")
	sb.WriteString("  ...args: [...RouteParams<T> extends never ? [] : [params: RouteParams<T>], options?: NavigateOptions]\n")
	sb.WriteString("): void {\n")
	sb.WriteString("  let url = buildRoute(path, ...(args.length > 0 && typeof args[0] === 'object' && !('replace' in args[0]) ? [args[0]] : []));\n")
	sb.WriteString("  \n")
	sb.WriteString("  const options = args.find(a => typeof a === 'object' && 'replace' in a) as NavigateOptions | undefined;\n")
	sb.WriteString("  \n")
	sb.WriteString("  if (options?.query) {\n")
	sb.WriteString("    url += buildQuery(options.query);\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  if (options?.replace) {\n")
	sb.WriteString("    window.history.replaceState(options.state ?? {}, '', url);\n")
	sb.WriteString("  } else {\n")
	sb.WriteString("    window.history.pushState(options.state ?? {}, '', url);\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  // Dispatch popstate to trigger route change\n")
	sb.WriteString("  window.dispatchEvent(new PopStateEvent('popstate'));\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Create a link props object for use with anchor elements.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function getLinkProps<T extends RoutePath>(\n")
	sb.WriteString("  path: T,\n")
	sb.WriteString("  ...args: [...RouteParams<T> extends never ? [] : [params: RouteParams<T>], query?: RouteQuery]\n")
	sb.WriteString("): { href: string } {\n")
	sb.WriteString("  let href = buildRoute(path, ...(args.length > 0 && typeof args[0] === 'object' && !('search' in args[0]) ? [args[0]] : []));\n")
	sb.WriteString("  \n")
	sb.WriteString("  const query = args.find(a => typeof a === 'object' && !('toString' in a)) as RouteQuery | undefined;\n")
	sb.WriteString("  \n")
	sb.WriteString("  if (query) {\n")
	sb.WriteString("    href += buildQuery(query);\n")
	sb.WriteString("  }\n")
	sb.WriteString("  \n")
	sb.WriteString("  return { href };\n")
	sb.WriteString("}\n")
}

// generateRouteRegistry generates the route registry.
func (g *RouteTypeScriptGenerator) generateRouteRegistry(sb *strings.Builder) {
	sb.WriteString("/**\n")
	sb.WriteString(" * Route metadata interface.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export interface RouteMeta {\n")
	sb.WriteString("  path: RoutePath;\n")
	sb.WriteString("  name: string;\n")
	sb.WriteString("  isDynamic: boolean;\n")
	sb.WriteString("  params: string[];\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * All registered routes with metadata.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export const routes: RouteMeta[] = [\n")

	for _, route := range g.routes {
		if route.IsLayout {
			continue
		}
		routeName := g.pathToName(route.URLPath)
		sb.WriteString("  {\n")
		sb.WriteString(fmt.Sprintf("    path: %q,\n", route.URLPath))
		sb.WriteString(fmt.Sprintf("    name: %q,\n", routeName))
		sb.WriteString(fmt.Sprintf("    isDynamic: %v,\n", route.IsDynamic))
		sb.WriteString(fmt.Sprintf("    params: %v,\n", g.formatStringArray(route.RouteParams)))
		sb.WriteString("  },\n")
	}

	sb.WriteString("];\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Find a route by path.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function findRoute(path: string): RouteMeta | undefined {\n")
	sb.WriteString("  return routes.find(r => r.path === path);\n")
	sb.WriteString("}\n\n")

	sb.WriteString("/**\n")
	sb.WriteString(" * Find routes matching a pattern.\n")
	sb.WriteString(" */\n")
	sb.WriteString("export function findRoutesByPattern(pattern: RegExp): RouteMeta[] {\n")
	sb.WriteString("  return routes.filter(r => pattern.test(r.path));\n")
	sb.WriteString("}\n")
}

// pathToName converts a URL path to a route name.
func (g *RouteTypeScriptGenerator) pathToName(path string) string {
	if path == "/" {
		return "Home"
	}

	parts := strings.Split(strings.Trim(path, "/"), "/")
	var name strings.Builder

	for _, part := range parts {
		if strings.HasPrefix(part, ":") {
			// Dynamic segment - use "By" prefix
			name.WriteString("By")
			name.WriteString(strings.Title(strings.TrimPrefix(part, ":")))
		} else {
			name.WriteString(strings.Title(part))
		}
	}

	return name.String()
}

// pathToFuncName converts a URL path to a function name.
func (g *RouteTypeScriptGenerator) pathToFuncName(path string) string {
	if path == "/" {
		return "homeRoute"
	}

	parts := strings.Split(strings.Trim(path, "/"), "/")
	var name strings.Builder

	for i, part := range parts {
		if strings.HasPrefix(part, ":") {
			// Dynamic segment - skip in function name
			continue
		}
		if i == 0 {
			name.WriteString(strings.ToLower(part[:1]) + part[1:])
		} else {
			name.WriteString(strings.Title(part))
		}
	}

	name.WriteString("Route")
	return name.String()
}

// formatStringArray formats a string array for TypeScript output.
func (g *RouteTypeScriptGenerator) formatStringArray(arr []string) string {
	if len(arr) == 0 {
		return "[]"
	}

	var sb strings.Builder
	sb.WriteString("[")
	for i, s := range arr {
		if i > 0 {
			sb.WriteString(", ")
		}
		sb.WriteString(fmt.Sprintf("%q", s))
	}
	sb.WriteString("]")
	return sb.String()
}
