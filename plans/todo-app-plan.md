# Todo App — GoSPA Example

**Location:** `examples/todo-app/`  
**Purpose:** Showcase the core GoSPA patterns in a realistic, feature-complete example.

---

## What it demonstrates

| Feature | Pattern used |
|---------|-------------|
| File-based routing | `routes/page.templ`, `routes/layout.templ` |
| `data-gospa-component` + `data-gospa-state` | Inline JSON state on the server |
| `data-bind` / `data-on` | Declarative DOM wiring in templ files |
| Remote actions (`/_gospa/remote/:name`) | `routing.RegisterRemoteAction` for server-side mutations |
| WebSocket real-time sync | `gospa.Config{EnableWebSocket: true}` |
| SSE live broadcast | `fiber.NewSSEBroker` + `fiber.SetupSSE` |
| Filtering (derived client state) | `GoSPA.Derived` computed from the todo list |
| Keyboard shortcut | `GoSPA.onKey(['enter'], ...)` |
| SPA navigation | `<a href="/about">` navigates without reload |
| `data-transition` | `fade` / `fly` on item add/remove |
| DevMode + HMR | `gospa.Config{DevMode: true}` |

---

## Project layout

```
examples/todo-app/
├── go.mod                         # module todo-app, replace => ../../
├── main.go                        # gospa.New(...) + SSE broker + remote actions
├── routes/
│   ├── layout.templ               # Root HTML shell (Tailwind CDN, title)
│   ├── page.templ                 # "/" — todo list UI
│   ├── about/
│   │   └── page.templ             # "/about" — static info page (SPA nav demo)
│   └── generated_routes.go        # generated by: go run ../cmd/gospa generate
└── static/                        # (empty, framework serves /_gospa/runtime.js)
```

---

## Step-by-step

### Step 0 — Scaffold

```bash
# from examples/
go run ../cmd/gospa create todo-app
# or equivalently if cwd is examples/todo-app:
go run ../../cmd/gospa create .
```

Then update the module replace directive in `go.mod`:

```
replace github.com/aydenstechdungeon/gospa => ../../
```

---

### Step 1 — `go.mod`

```go
module todo-app

go 1.24.0

require (
    github.com/a-h/templ v0.3.977
    github.com/aydenstechdungeon/gospa v0.1.0
)

replace github.com/aydenstechdungeon/gospa => ../../
```

---

### Step 2 — `main.go`

Wire up the app: GoSPA instance, SSE broker, remote actions, and server start.

```go
package main

import (
    "log"

    _ "todo-app/routes" // triggers init() — registers all pages/layouts

    "github.com/aydenstechdungeon/gospa"
    gfiber "github.com/aydenstechdungeon/gospa/fiber"
    "github.com/aydenstechdungeon/gospa/routing"
)

// In-memory store (swap for a DB in production)
var todos = []map[string]any{}
var nextID = 1

func main() {
    app := gospa.New(gospa.Config{
        RoutesDir:       "./routes",
        AppName:         "GoSPA Todo",
        DevMode:         true,
        EnableWebSocket: true,
    })

    // ── SSE broker (live broadcast of todo changes) ───────────────────────
    broker := gfiber.NewSSEBroker(&gfiber.SSEConfig{
        HeartbeatInterval: 30_000_000_000, // 30s in nanoseconds
    })
    gfiber.SetupSSE(app.Fiber, broker, "/_sse")

    // ── Remote actions ─────────────────────────────────────────────────────
    //
    // addTodo
    //   body: { "text": "Buy milk" }
    //   returns: updated []map[string]any
    routing.RegisterRemoteAction("addTodo", func(ctx *routing.RemoteContext) (any, error) {
        var body struct {
            Text string `json:"text"`
        }
        if err := ctx.ParseBody(&body); err != nil || body.Text == "" {
            return nil, ctx.BadRequest("text is required")
        }
        todo := map[string]any{
            "id":        nextID,
            "text":      body.Text,
            "completed": false,
        }
        nextID++
        todos = append(todos, todo)
        broker.Broadcast(gfiber.SSEEvent{Event: "todos", Data: todos})
        return todos, nil
    })

    //
    // toggleTodo
    //   body: { "id": 1 }
    routing.RegisterRemoteAction("toggleTodo", func(ctx *routing.RemoteContext) (any, error) {
        var body struct {
            ID int `json:"id"`
        }
        if err := ctx.ParseBody(&body); err != nil {
            return nil, ctx.BadRequest("id is required")
        }
        for i, t := range todos {
            if int(t["id"].(int)) == body.ID {
                todos[i]["completed"] = !t["completed"].(bool)
            }
        }
        broker.Broadcast(gfiber.SSEEvent{Event: "todos", Data: todos})
        return todos, nil
    })

    //
    // deleteTodo
    //   body: { "id": 1 }
    routing.RegisterRemoteAction("deleteTodo", func(ctx *routing.RemoteContext) (any, error) {
        var body struct {
            ID int `json:"id"`
        }
        if err := ctx.ParseBody(&body); err != nil {
            return nil, ctx.BadRequest("id is required")
        }
        filtered := todos[:0]
        for _, t := range todos {
            if int(t["id"].(int)) != body.ID {
                filtered = append(filtered, t)
            }
        }
        todos = filtered
        broker.Broadcast(gfiber.SSEEvent{Event: "todos", Data: todos})
        return todos, nil
    })

    //
    // clearCompleted
    routing.RegisterRemoteAction("clearCompleted", func(ctx *routing.RemoteContext) (any, error) {
        filtered := todos[:0]
        for _, t := range todos {
            if !t["completed"].(bool) {
                filtered = append(filtered, t)
            }
        }
        todos = filtered
        broker.Broadcast(gfiber.SSEEvent{Event: "todos", Data: todos})
        return todos, nil
    })

    if err := app.Run(":3000"); err != nil {
        log.Fatal(err)
    }
}
```

> **Note on `routing.RemoteContext`:** Check the actual generated signature from `docs/API.md` — if the framework uses a simpler `func(c *fiber.Ctx) (any, error)` style, adapt accordingly.

---

### Step 3 — `routes/layout.templ`

Standard shell identical to the `counter` example pattern, with a nav bar linking `/` and `/about`.

```go
package routes

templ Layout(title string, children templ.Component) {
    <!DOCTYPE html>
    <html lang="en" data-gospa-auto>
        <head>
            <meta charset="UTF-8"/>
            <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
            <title>{ title } — GoSPA Todo</title>
            <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
            <style>
                body { background: #0f172a; color: #f8fafc; }
            </style>
        </head>
        <body class="bg-slate-950 min-h-screen">
            <nav class="flex items-center gap-6 px-8 py-4 border-b border-white/10">
                <a href="/" class="font-bold text-white">Todo</a>
                <a href="/about" class="text-slate-400 hover:text-white transition-colors text-sm">About</a>
            </nav>
            <main class="container mx-auto px-4 py-8 max-w-2xl">
                @templ.Component(children)
            </main>
        </body>
    </html>
}
```

---

### Step 4 — `routes/page.templ`

The main todo page. All interactivity is wired via `data-gospa-component`, `data-gospa-state`, `data-bind`, and `data-on`. Remote actions are called from inline `onclick` via `__GOSPA__`.

```go
package routes

templ Page() {
    <div
        data-gospa-component="todos"
        data-gospa-state='{"todos":[],"filter":"all","newText":""}'
    >
        <h1 class="text-3xl font-extrabold mb-2 text-white">Todo List</h1>
        <p class="text-slate-400 text-sm mb-6">
            Real-time via WebSocket · Live broadcast via SSE
        </p>

        <!-- Input row -->
        <form
            class="flex gap-2 mb-6"
            onsubmit="event.preventDefault(); __GOSPA_TODO__.add()"
        >
            <input
                id="todo-input"
                type="text"
                data-model="newText"
                placeholder="What needs to be done?"
                class="flex-1 px-4 py-3 bg-slate-800 border border-white/10 rounded-xl text-white placeholder-slate-500 focus:outline-none focus:border-blue-500"
            />
            <button
                type="submit"
                class="px-6 py-3 bg-blue-600 hover:bg-blue-500 rounded-xl font-bold transition-all"
            >
                Add
            </button>
        </form>

        <!-- Filter tabs -->
        <div class="flex gap-2 mb-4 text-sm">
            <button data-on="click:filter-all"   class="px-4 py-1.5 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors">All</button>
            <button data-on="click:filter-active" class="px-4 py-1.5 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors">Active</button>
            <button data-on="click:filter-done"  class="px-4 py-1.5 rounded-lg bg-slate-700 hover:bg-slate-600 transition-colors">Completed</button>
        </div>

        <!-- Todo list (rendered by client runtime list binding) -->
        <ul
            id="todo-list"
            class="space-y-2"
            data-bind="list:filteredTodos"
            data-item-name="todo"
        >
            <!-- Item template — repeated per item -->
            <li
                class="flex items-center gap-3 p-4 bg-slate-800/60 rounded-xl border border-white/5 group"
                data-transition="fly"
            >
                <input
                    type="checkbox"
                    class="w-5 h-5 rounded accent-blue-500 cursor-pointer"
                    data-on="change:toggle"
                />
                <span
                    class="flex-1 text-white"
                    data-bind="text:todo.text"
                ></span>
                <button
                    class="opacity-0 group-hover:opacity-100 text-slate-500 hover:text-red-400 transition-all text-lg leading-none"
                    data-on="click:delete"
                    aria-label="Delete"
                >
                    ×
                </button>
            </li>
        </ul>

        <!-- Footer -->
        <div class="flex items-center justify-between mt-6 text-sm text-slate-400">
            <span data-bind="text:remaining"></span>
            <button
                data-on="click:clear-completed"
                class="hover:text-white transition-colors"
            >
                Clear completed
            </button>
        </div>
    </div>

    <!-- Client-side logic (inline script, safe — not sanitized, lives in layout) -->
    <script type="module">
    // This block registers the component's action handlers.
    // It runs once on hydration because it is inside data-gospa-component's subtree.
    // See: docs/API.md — "Event Handling Patterns"
    </script>
}
```

> **Inline JS note:** Complex client logic (the `__GOSPA_TODO__` helper and `data-on` handler registrations) goes into the `layout.templ` in a `<script type="module">` **outside** the component root, so DOMPurify doesn't strip it during SPA navigation. The script listens to `data-on` via GoSPA's built-in dispatcher.

---

### Step 5 — `routes/about/page.templ`

Static page to demonstrate SPA navigation.

```go
package routes

templ AboutPage() {
    <div class="prose prose-invert max-w-none">
        <h1 class="text-3xl font-bold text-white mb-4">About</h1>
        <p class="text-slate-400">
            This is the <strong>GoSPA Todo</strong> example application.
            It demonstrates file-based routing, reactive state, remote actions,
            SSE broadcasting, and SPA navigation — all in a single Go binary.
        </p>
        <ul class="mt-6 space-y-2 text-slate-300 list-disc list-inside">
            <li>Server: Go + Fiber via GoSPA</li>
            <li>Templates: <code>a-h/templ</code></li>
            <li>Client runtime: GoSPA (~17 KB with DOMPurify)</li>
            <li>Real-time: WebSocket state sync + SSE broadcast</li>
        </ul>
        <a href="/" class="inline-block mt-8 text-blue-400 hover:underline">← Back to todos</a>
    </div>
}
```

---

### Step 6 — `routes/generated_routes.go`

**Do not write this by hand.** Run:

```bash
# from examples/todo-app/
go run ../../cmd/gospa generate
```

Expected output:

```go
// Code generated by gospa route generator. DO NOT EDIT.
package routes

import (
    "github.com/a-h/templ"
    "github.com/aydenstechdungeon/gospa/routing"
)

func init() {
    routing.RegisterPage("/", func(props map[string]interface{}) templ.Component {
        return Page()
    })

    routing.RegisterPage("/about", func(props map[string]interface{}) templ.Component {
        return AboutPage()
    })

    routing.RegisterLayout("/", func(children templ.Component, props map[string]interface{}) templ.Component {
        return Layout(func() string {
            if v, ok := props["title"].(string); ok { return v }
            return "Home"
        }(), children)
    })
}
```

---

### Step 7 — Client-side script (in `layout.templ`)

Place this **before `</body>`** so it survives SPA navigation:

```html
<script type="module">
// ── Todo component handlers ───────────────────────────────────────────────
// Registers action handlers for data-on="click:*" inside [data-gospa-component="todos"]

const COMPONENT = 'todos';

function getTodos() {
    return __GOSPA__.getState(COMPONENT, 'todos')?.get() ?? [];
}

function getFilter() {
    return __GOSPA__.getState(COMPONENT, 'filter')?.get() ?? 'all';
}

function setTodos(list) {
    __GOSPA__.setState(COMPONENT, 'todos', list);
    // recompute derived "filteredTodos" and "remaining"
    updateDerived();
}

function updateDerived() {
    const filter = getFilter();
    const todos  = getTodos();
    const filtered = todos.filter(t =>
        filter === 'all'    ? true :
        filter === 'active' ? !t.completed :
                              t.completed
    );
    __GOSPA__.setState(COMPONENT, 'filteredTodos', filtered);
    const rem = todos.filter(t => !t.completed).length;
    __GOSPA__.setState(COMPONENT, 'remaining',
        rem === 1 ? '1 item left' : `${rem} items left`
    );
}

// ── Remote action helper ──────────────────────────────────────────────────
async function remote(name, body) {
    const res = await fetch(`/_gospa/remote/${name}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
}

// ── Action handlers (data-on) ─────────────────────────────────────────────
// GoSPA dispatches data-on="click:increment" as GoSPA.callAction("increment")
// Register the handlers below with the component's action dispatcher.

window.__GOSPA_TODO__ = {
    async add() {
        const input = document.getElementById('todo-input');
        const text  = __GOSPA__.getState(COMPONENT, 'newText')?.get()?.trim() ?? '';
        if (!text) return;
        const updated = await remote('addTodo', { text });
        setTodos(updated);
        __GOSPA__.setState(COMPONENT, 'newText', '');
    },
};

// Register data-on handlers via the component action system
// (exact API depends on gospa runtime version; adapt as needed)
if (typeof GoSPA !== 'undefined') {
    GoSPA.registerAction(COMPONENT, 'filter-all',   () => { __GOSPA__.setState(COMPONENT,'filter','all'); updateDerived(); });
    GoSPA.registerAction(COMPONENT, 'filter-active',() => { __GOSPA__.setState(COMPONENT,'filter','active'); updateDerived(); });
    GoSPA.registerAction(COMPONENT, 'filter-done',  () => { __GOSPA__.setState(COMPONENT,'filter','completed'); updateDerived(); });

    GoSPA.registerAction(COMPONENT, 'toggle', async (e, context) => {
        const id = context.item?.id;
        if (id == null) return;
        const updated = await remote('toggleTodo', { id });
        setTodos(updated);
    });

    GoSPA.registerAction(COMPONENT, 'delete', async (e, context) => {
        const id = context.item?.id;
        if (id == null) return;
        const updated = await remote('deleteTodo', { id });
        setTodos(updated);
    });

    GoSPA.registerAction(COMPONENT, 'clear-completed', async () => {
        const updated = await remote('clearCompleted', {});
        setTodos(updated);
    });
}

// ── SSE: receive live updates from other sessions ─────────────────────────
const clientId = crypto.randomUUID();
const es = new EventSource(`/_sse/connect?clientId=${clientId}`);
es.addEventListener('todos', (ev) => {
    const todos = JSON.parse(ev.data);
    setTodos(todos);
});

// ── Keyboard shortcut: Enter to add ──────────────────────────────────────
document.getElementById('todo-input')?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); window.__GOSPA_TODO__.add(); }
});

// Initial derived computation
updateDerived();
</script>
```

---

## Best practices applied

- **No inline `onclick` on SPA-navigated content** — all event handlers use `data-on` + registered actions or `data-action` global delegation, so DOMPurify doesn't strip them.
- **Server is the source of truth** — remote actions mutate the in-memory store and SSE broadcasts to all connected clients.
- **WebSocket sync** — GoSPA automatically syncs `data-gospa-state` key changes across the WS hub.
- **Minimal server state on page load** — `data-gospa-state` starts with `{"todos":[]}` and the first load fetches nothing; the client hydrates from the DOM token.
- **SSE for cross-session** — all open browser tabs receive `todos` events and update their local state without polling.
- **`DevMode: true`** — enables request logging, route printing, and debug labels in the client runtime.
- **`go run ../../cmd/gospa generate`** — always regenerate `generated_routes.go` after adding/renaming routes.

---

## Run

```bash
# From examples/todo-app/
go run ../../cmd/gospa generate   # regenerate routes
go run .                           # or: go run ../../cmd/gospa dev
```

Open [http://localhost:3000](http://localhost:3000).

---

## Potential follow-up enhancements (out of scope for v1)

- Use `data-gospa-mode="visible"` island hydration for a below-fold stats widget
- Add HMR via `fiber.InitHMR(...)` for template hot-reload during development
