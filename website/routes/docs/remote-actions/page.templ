package remoteactions

import "website/components"

templ Page() {
	<div class="space-y-12">
		<header>
			<h1 class="text-4xl font-bold tracking-tight mb-4 text-transparent bg-clip-text bg-gradient-to-r from-[var(--accent-primary)] to-[var(--accent-secondary)]">Remote Actions</h1>
			<p class="text-xl text-[var(--text-secondary)] leading-relaxed">
				Type-safe server functions called directly from your Svelte-like templates or client-side scripts.
			</p>
		</header>

		<nav class="flex flex-wrap gap-4 p-4 rounded-2xl bg-[var(--bg-secondary)] border border-[var(--border)]">
			<a href="#defining" class="text-sm font-medium hover:text-[var(--accent-primary)] transition-colors">Defining Actions</a>
			<a href="#complex-input" class="text-sm font-medium hover:text-[var(--accent-primary)] transition-colors">Complex Inputs</a>
			<a href="#calling-template" class="text-sm font-medium hover:text-[var(--accent-primary)] transition-colors">Calling from Template</a>
			<a href="#calling-script" class="text-sm font-medium hover:text-[var(--accent-primary)] transition-colors">Calling from Script</a>
			<a href="#csrf-protection" class="text-sm font-medium hover:text-[var(--accent-primary)] transition-colors">CSRF Protection</a>
		</nav>

		<section id="defining" class="space-y-6">
			<h2 class="text-2xl font-bold border-b border-[var(--border)] pb-2">Defining Actions</h2>
			<p class="text-[var(--text-secondary)]">
				Remote actions are registered globally using the <code class="mono text-[var(--accent-primary)]">routing</code> package. They receive a context and an interface which contains the parsed JSON input from the client.
			</p>
			@components.CodeBlock(`import "github.com/aydenstechdungeon/gospa/routing"

func init() {
    routing.RegisterRemoteAction("greet", func(ctx context.Context, input any) (any, error) {
        name := input.(string)
        return "Hello, " + name, nil
    })
}`, "go", "actions.go")
		</section>

		<section id="complex-input" class="space-y-6">
			<h2 class="text-2xl font-bold border-b border-[var(--border)] pb-2">Complex Inputs & Validation</h2>
			<p class="text-[var(--text-secondary)]">
				Since inputs are passed as <code class="mono">any</code>, you should use type assertions or a library like <code class="mono">mitchellh/mapstructure</code> to map to your structs.
			</p>
			@components.CodeBlock(`type CreateUser struct {
    Username string ` + "`" + `json:"username"` + "`" + `
    Email    string ` + "`" + `json:"email"` + "`" + `
}

routing.RegisterRemoteAction("createUser", func(ctx context.Context, input any) (any, error) {
    var data CreateUser
    // Map input to struct...
    if data.Username == "" {
        return nil, errors.New("username required")
    }
    return "User " + data.Username + " created", nil
})`, "go", "user.go")
		</section>

		<section id="calling-template" class="space-y-6">
			<h2 class="text-2xl font-bold border-b border-[var(--border)] pb-2">Calling from Templates</h2>
			<p class="text-[var(--text-secondary)]">
				Trigger remote actions programmatically via JavaScript event handlers.
			</p>
			@components.CodeBlock(`<button 
    onclick="handleGreet()"
    class="px-4 py-2 bg-blue-600 rounded"
>
    Greet Me
</button>

<script>
async function handleGreet() {
    const result = await remote('greet', 'GoSPA User');
    if (result.ok) {
        console.log(result.data);
    }
}
</script>`, "templ", "page.templ")
		</section>

		<section id="calling-script" class="space-y-6">
			<h2 class="text-2xl font-bold border-b border-[var(--border)] pb-2">Calling from Script</h2>
			<p class="text-[var(--text-secondary)]">
				You can also call remote actions programmatically using the <code class="mono text-[var(--accent-primary)]">remote</code> function from the runtime.
			</p>
			@components.CodeBlock(`import { remote } from '@gospa/runtime';

async function handleSignup() {
    const result = await remote('createUser', {
        username: 'ayden',
        email: 'ayden@example.com'
    });
    
    if (result.error) {
        alert('Error: ' + result.error);
    } else {
        console.log('Success:', result.data);
    }
}`, "typescript", "signup.ts")
		</section>

		<section id="csrf-protection" class="space-y-6">
			<h2 class="text-2xl font-bold border-b border-[var(--border)] pb-2">CSRF Protection</h2>
			<p class="text-[var(--text-secondary)]">
				When CSRF protection is enabled in your app configuration, remote actions require a valid CSRF token. The token is automatically set as a cookie by the middleware.
			</p>
			@components.CodeBlock(`// Server configuration
app := gospa.New(gospa.Config{
    EnableCSRF: true,
})

// Middleware setup (required)
app.Use(fiber.CSRFSetTokenMiddleware())  // Issues csrf_token cookie
app.Use(fiber.CSRFTokenMiddleware())       // Validates X-CSRF-Token header`, "go", "csrf.go")
			<p class="text-[var(--text-secondary)]">
				The client automatically reads the <code class="mono">csrf_token</code> cookie and sends it as the <code class="mono">X-CSRF-Token</code> header with each remote action request.
			</p>
		</section>

		<div class="bg-amber-500/5 border border-amber-500/20 p-6 rounded-2xl">
			<h4 class="text-amber-500 font-bold mb-2">Security Note</h4>
			<p class="text-sm text-[var(--text-secondary)]">
				Remote actions are public endpoints. Always perform authentication and authorization checks inside your action functions using the provided <code class="mono">context.Context</code>. Extract session information from the context and validate permissions before executing sensitive operations.
			</p>
		</div>
	</div>
}
